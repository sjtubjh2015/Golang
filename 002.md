# 第二章    程序结构

## 2.1. 命名

**命名规则：**一个名字必须以字母或下划线开头，后接任意数量的字母、数字、下划线。

如果一个名字是在函数内部定义的，那么它就只在函数内部有效。如果是在函数外部定义，那么在当前包的所有文件中都可以访问（包级名字）。名字的开头字母的大小写决定了名字在包外的可见性。如果一个名字是大写字母开头的（必须是在函数外部定义的包级名字，包级函数名本身也是包级名字），那么它将是导出的，也就是说可以被外部的包访问。包本身的名字一般总是用小写字母。

**驼峰式命名**

## 2.2. 声明

```go
var  		变量
const		常量
type 		类型
func 		函数
```

一个Go语言编写的程序对应一个或多个以.go为文件后缀名的源文件。每个源文件中以包的声明语句开始，说明源文件是属于哪个包。包声明语句之后是import语句导入依赖的其他包。然后是包一级的类型、变量、常量、函数的声明语句，包一级的各种类型的声明语句的顺序无关紧要，函数内部的名字则必须先声明之后才能使用。

在包一级声明语句声明的名字可在整个包对应的每个源文件中访问，而不是仅仅在其声明语句所在的源文件中访问。相比之下，局部声明的名字只能在函数内部很小的范围内被访问。

## 2.3. 变量

变量声明的一般语法如下：

```go
var name type = expression
```

其中，"type"或 "expression" 可以省略其中一个。如果省略类型，则根据初始化表达式来推导变量的类型；如果省略表达式，则用该类型的零值初始化变量。

```go
数值类型     		0
布尔类型     		false
字符串类型   		""				
接口或引用类型		nil
数组和结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值
```

零值初始化机制可以确保每个声明的变量总是有一个良好定义的值，因此在Go语言中不存在未初始化的变量。

可以在一个声明语句中同时声明一组变量，或用一组初始化表达式声明并初始化一组变量。如果省略每个变量的类型，将可以声明多个类型不同的变量（类型由初始化表达式推导）：

```go
var i, j, k int                		// int, int, int
var b, f, s = true, 2.3, "four"		// bool, float64, string
```

初始化表达式可以是字面量或任意表达式。在包级别声明的变量会在main入口函数执行前完成初始化，局部变量将在声明语句被执行到的时候完成初始化。

一组变量也可以通过调用一个函数，由函数返回的多个返回值初始化:

```go
var f, err = os.Open(name)
```

### 2.3.1. 简短变量声明

在函数内部，简短变量声明语句可用于声明和初始化局部变量：

```go
name := expression
```

变量的类型根据表达式来自动推导。

因为简洁和灵活的特点，简短声明变量被广泛用于大部分的局部变量的声明和初始化。var形式的声明语句往往是用于需要显式指定变量类型的地方，或者因为变量稍后会被重新赋值而初始值无关紧要的地方。

和var形式声明语句一样，简短变量声明语句也可以用来声明和初始化一组变量：

```go
i, j := 0, 1
```

也可以用函数的返回值来声明和初始化变量：

```go
f, err := os.Open(name)
```

简短变量声明语句中必须至少声明一个新的变量，对已经声明过的变量只做赋值。

简短变量声明语句只有对已经在同级词法域声明过的变量才和赋值操作语句等价，如果变量是在外部词法域声明的，那么简短变量声明语句将会在当前词法域重新声明一个变量。

### 2.3.2. 指针

一个变量是保存一个值的内存空间。

一个指针的值是另一个变量的地址。一个指针对应变量在内存中的存储位置。并不是每一个值都有会有一个内存地址，但是对于每一个变量必然有对应的内存地址。通过指针，我们可以间接读或更新对应变量的值，而不需要知道该变量的名字。

```go
var x int      				x := 0
var p *int = &x				p := &x
*p = 2         				*p = 2
fmt.Println(*p)				fmt.Println(*p)
// &x表达式产生一个指向该整数变量的指针
// 指针对应的数据类型是 *int
// 指针被称为指向int类型的指针
// *p表达式对应p指针指向的变量的值
```

任何类型的指针的零值都是nil。如果p指向某个有效变量，那么p != nil为真。指针之间也是可以进行相等测试的，只有当它们指向同一个变量或全部是nil时才相等。

返回函数中局部变量的地址也是安全的。

每次对一个变量取地址，或者复制指针，都为原变量创建了新的别名。

### 2.3.3. new函数

```go
p := new(int)  		// p, *int类型，指向匿名的int变量
fmt.Println(*p)		// "0"
*p = 2         		// 设置int匿名变量的值为2
fmt.Println(*p)		// "2"
```

表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为*T。

### 2.3.4. 变量的生命周期

变量的生命周期指的是在程序运行期间变量有效存在的时间段。对于在包级别声明的变量，它们的生命周期和整个程序的运行周期是一致的。相比之下，局部变量的生命周期是动态的：每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后该变量的存储空间可能被回收。函数的参数变量和返回值变量都是局部变量，它们在函数每次被调用时创建。

因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。

如果将指向短生命周期对象的指针保存到具有长生命周期的对象中，特别是保存到全局变量时，会阻止对短生命周期对象的垃圾回收。

## 2.4. 赋值

自增/自减是语句而不是表达式。

### 2.4.1. 元组赋值

元组赋值是另一种形式的赋值语句，它允许同时更新多个变量的值。在赋值之前，赋值语句右边的所有表达式将会先进行求值，然后再统一更新左边对应变量的值。

```go
x, y = y, x
i, j, k = 2, 3, 5
```

### 2.4.2. 可赋值性

## 2.5. 类型

一个类型声明语句创建了一个新的类型名称，和现有类型具有相同的底层结构。新命名的类型提供了一个方法，用来分隔不同概念的类型，这样即使它们底层类型相同也是不兼容的。

```go
type name underlying_type
```

类型声明语句一般出现在包一级，因此如果新创建的类型名字的首字符大写，则在包外部也可以使用。

```go
类型转换操作   		T(x)
如果T是指针类型		(*T)(x)
```

命名类型还可以为该类型的值定义新的行为。这些行为表示为一组关联到该类型的函数集合，我们称为类型的方法集。

## 2.6. 包和文件

每个包都对应一个独立的名字空间。要在外部引用函数，必须显式使image.Decode或utf16.Decode形式访问。

### 2.6.1. 导入包

### 2.6.2. 包的初始化

包的初始化首先解决包级变量的依赖顺序，然后按照包级变量声明出现的顺序依次初始化：

```go
var a = b + c		// a第三个初始化，为3
var b = f()  		// b第二个初始化，为2
var c = 1    		// c第一个初始化，为1
func f() int { return c + 1 }
```

如果包中含有多个.go源文件，它们将按照发给编译器的顺序进行初始化，Go语言的构建工具首先会将.go文件根据文件名排序，然后依次调用编译器编译。

init初始化函数：

```go
func init() { /* …… */ }
```

每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次。因此，如果一个p包导入了q包，那么在p包初始化的时候可以认为q包必然已经初始化过了。初始化工作是自上而下进行的，main包最后被初始化。以这种方式，可以确保在main函数执行前，所有依赖的包都已经完成初始化工作了。

## 2.7. 作用域

一个声明语句将程序中的实体和名字关联，比如一个函数或一个变量。声明语句的作用域是指源代码中可以有效使用这个名字的范围。

声明语句的作用域对应的是一个源代码的文本区域；它是一个编译时的属性。一个变量的生命周期是指程序运行时变量存在的有效时间段，在此时间区域内它可以被程序的其他部分引用；是一个运行时的概念。

声明语句对应的词法域决定了作用域范围的大小。对于内置的类型、函数和常量，比如int、len和true等是在全局作用域的，因此可以在整个程序中直接使用。任何在函数外部（也就是包级语法域）声明的名字可以在同一个包的任何源文件中访问。对于导入的包，例如tempconv导入的fmt包，则是对应源文件级的作用域，因此只能在当前的文件中访问导入的fmt包，当前包的其他源文件无法访问在当前源文件导入的包。还有许多声明语句，比如tempconv.CToF函数中的变量c，则是局部作用域的，它只能在函数内部（甚至只能是局部的某些部分）访问。

当编译器遇到一个名字引用时，它会对其定义进行查找，查找过程从最内层的词法域向全局的作用域进行。如果查找失败，则报告“未声明的名字”这样的错误。如果该名字在内部和外部的块分别声明过，则内部块的声明首先被找到。在这种情况下，内部声明屏蔽了外部同名的声明，让外部的声明的名字无法被访问。

for语句创建了两个词法域：花括号包含的是显式的部分，是for的循环体部分词法域；另外一个隐式的部分则是循环的初始化部分，比如用于迭代变量i的初始化。隐式的词法域部分的作用域还包含条件测试部分和循环后的迭代部分，当然也包含循环体词法域。

和for循环类似，if和switch语句也会在条件部分创建隐式词法域，还有它们对应的执行体词法域。

在包级别，声明的顺序并不会影响作用域的范围，因此一个先声明的可以引用它自身或是引用后面的一个声明，这可以让我们定义一些相互嵌套或递归的类型或函数。但是如果一个变量或常量递归引用了自身，则会引起编译错误。

Go语言的习惯是在if中处理错误然后直接返回，这样可以确保正常执行的语句不需要代码缩进。